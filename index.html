<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CL-PLO | Continual Learning x Portfolio Optimization</title>
    <link rel="stylesheet" href="./coreline.css" />
  </head>
  <body>
    <header class="hero">
      <div class="shell">
        <p class="eyebrow">Continual Learning x Portfolio Optimization</p>
        <h1>A principled bridge: memory-safe model updates as risk control for live portfolios</h1>
        <p class="lead">
          The core question is operational, not academic: <strong>how do we adapt to drift without deleting stress
          memory</strong>? This page unifies continual-learning constraints and portfolio decision controls in one
          deployable mechanism.
        </p>
        <div class="hero-actions">
          <a class="btn btn-primary" href="#bridge">See The Bridge</a>
          <a class="btn btn-ghost" href="#atlas">Compare Strategies</a>
          <a class="btn btn-ghost" href="#validation">Run Validation</a>
        </div>
        <div class="hero-signal">
          <article>
            <h3>Decision scope</h3>
            <p>Only the adapter update law changes.</p>
          </article>
          <article>
            <h3>System constant</h3>
            <p>Same optimizer, same constraints, same stream.</p>
          </article>
          <article>
            <h3>Deployment objective</h3>
            <p>Retain stress behavior while fitting new drift.</p>
          </article>
        </div>
      </div>
    </header>

    <main class="shell">
      <section id="bridge" class="section">
        <h2>1. The Missing Bridge</h2>
        <p class="section-intro">
          Portfolio teams already constrain turnover and exposure to control harmful moves. Continual learning needs the
          same discipline in parameter space: control harmful update directions while preserving useful adaptation.
        </p>

        <div class="bridge-frame">
          <article class="bridge-side">
            <h3>Continual learning side</h3>
            <p>Unconstrained drift gradients can overwrite stress memory.</p>
            <p class="bridge-note">Failure mode: catastrophic forgetting after long drift runs.</p>
          </article>

          <article class="bridge-core">
            <h3>Shared principle</h3>
            <p>Constrain damaging motion, preserve productive motion.</p>
            <p class="math-block">
              \[
              \text{minimize adaptation loss}
              \quad\text{s.t.}\quad
              \text{interference budget} \le \varepsilon
              \]
            </p>
          </article>

          <article class="bridge-side">
            <h3>Portfolio control side</h3>
            <p>Unconstrained weight shifts create cost and drawdown instability.</p>
            <p class="bridge-note">Failure mode: paper alpha erased by implementation friction.</p>
          </article>
        </div>

        <div class="bridge-equations">
          <article class="eq-card">
            <h3>Update constraint (learning layer)</h3>
            <p class="math-block">
              \[
              \tilde{\mathbf{g}}=
              \arg\min_{\mathbf{g}}\lVert\mathbf{g}-\mathbf{g}_{\mathrm{d}}\rVert_2^2
              \;\text{s.t.}\;
              \langle\mathbf{g},\mathbf{g}_{\mathrm{a}}\rangle\ge-\varepsilon
              \]
            </p>
          </article>
          <article class="eq-card">
            <h3>Weight constraint (decision layer)</h3>
            <p class="math-block">
              \[
              \mathbf{w}_t^\star=
              \arg\min_{\mathbf{w}\in\mathcal{W}}
              \left(-\hat{\mu}_t^\top\mathbf{w}
              +\frac{\gamma}{2}\mathbf{w}^\top\hat{\Sigma}_t\mathbf{w}
              +\lambda_{\mathrm{tc}}\lVert\mathbf{w}-\mathbf{w}_{t-1}\rVert_1\right)
              \]
            </p>
          </article>
        </div>

        <p class="refs">
          References:
          <a href="https://openreview.net/forum?id=Hkf2_sC5FX" target="_blank" rel="noreferrer">A-GEM</a>,
          <a href="https://arxiv.org/abs/2405.13383" target="_blank" rel="noreferrer">projection in continual PEFT</a>,
          <a href="https://web.stanford.edu/~boyd/papers/pdf/cvx_portfolio.pdf" target="_blank" rel="noreferrer">multi-period portfolio control</a>,
          <a href="https://dl.acm.org/doi/10.1145/2638548" target="_blank" rel="noreferrer">online portfolio selection</a>.
        </p>
      </section>

      <section id="objects" class="section">
        <h2>2. One-to-One Mapping (CL ↔ Portfolio)</h2>
        <p class="section-intro">
          This is the spine of the post. Each continual-learning object has a direct portfolio-control counterpart and
          an implementation handle.
        </p>

        <article class="mapping-wrap">
          <table class="mapping-table">
            <thead>
              <tr>
                <th>Continual learning object</th>
                <th>Portfolio counterpart</th>
                <th>Implementation handle</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>\(\mathcal{D}^{\mathrm{drift}}_t\): non-stationary stream</td>
                <td>Current regime flow</td>
                <td>rolling drift minibatches</td>
              </tr>
              <tr>
                <td>\(\mathcal{D}^{\mathrm{anchor}}_t\): memory buffer</td>
                <td>Stress scenario library</td>
                <td>tagged crisis slices + pinned replay set</td>
              </tr>
              <tr>
                <td>\(\langle\mathbf{g},\mathbf{g}_{\mathrm{a}}\rangle\ge-\varepsilon\): stability cone</td>
                <td>risk budget inequality</td>
                <td>interference threshold \(\varepsilon\)</td>
              </tr>
              <tr>
                <td>\(\theta_t\): adapter state</td>
                <td>decision engine state</td>
                <td>LoRA adapter parameters only</td>
              </tr>
              <tr>
                <td>\((\hat{\mu}_t,\hat{\Sigma}_t)\)</td>
                <td>alpha + risk forecasts</td>
                <td>fixed forecast-to-optimizer interface</td>
              </tr>
              <tr>
                <td>\(\mathbf{w}_t^\star\)</td>
                <td>tradable portfolio</td>
                <td>turnover-penalized convex solve</td>
              </tr>
            </tbody>
          </table>
        </article>
      </section>

      <section id="stack" class="section">
        <h2>3. Shared Deployment Stack (Constant Across Methods)</h2>
        <p class="section-intro">All strategies run through the same infrastructure. Only the adapter update rule changes.</p>

        <figure class="stack-figure" aria-label="Shared CL-PLO system pipeline">
          <div class="stack-node">Input stream<br /><span>market + macro + text</span></div>
          <div class="stack-arrow">&rarr;</div>
          <div class="stack-node frozen">Frozen backbone \(\phi\)</div>
          <div class="stack-arrow">&rarr;</div>
          <div class="stack-node updated">Adapter \(\theta_t\)<br /><span>method-specific update</span></div>
          <div class="stack-arrow">&rarr;</div>
          <div class="stack-node">Forecasts \((\hat{\mu}_t,\hat{\Sigma}_t)\)</div>
          <div class="stack-arrow">&rarr;</div>
          <div class="stack-node">Optimizer \(\rightarrow \mathbf{w}_t^\star\)</div>
        </figure>
      </section>

      <section id="mechanism" class="section">
        <h2>4. Anchor Memory and Projection Mechanism</h2>
        <p class="section-intro">This is the critical mechanism: where retention is enforced and where adaptation is allowed.</p>

        <div class="mechanism-grid">
          <article class="mech-card">
            <h3>Anchor memory construction</h3>
            <table class="anchor-table">
              <thead>
                <tr>
                  <th>Regime tag</th>
                  <th>Memory slice</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Credit shock</td>
                  <td>spread widening + funding stress factors</td>
                </tr>
                <tr>
                  <td>Liquidity break</td>
                  <td>limit-down tape + microstructure stress</td>
                </tr>
                <tr>
                  <td>Inflation surprise</td>
                  <td>macro release text + factor regime reversal</td>
                </tr>
              </tbody>
            </table>
          </article>

          <article class="mech-card">
            <h3>Projection geometry</h3>
            <p class="math-block">
              \[
              \tilde{\mathbf{g}}=\Pi_{\mathcal{C}_\varepsilon}(\mathbf{g}_{\mathrm{d}}),
              \quad
              \mathcal{C}_\varepsilon=\{\mathbf{g}:\langle\mathbf{g},\mathbf{g}_{\mathrm{a}}\rangle\ge-\varepsilon\}
              \]
            </p>
            <figure class="projection-figure" aria-label="Gradient projection in feasible cone">
              <svg viewBox="0 0 320 170" role="img">
                <line x1="36" y1="138" x2="294" y2="138" stroke="#a7a7a7" stroke-width="1.5"></line>
                <line x1="36" y1="138" x2="36" y2="26" stroke="#a7a7a7" stroke-width="1.5"></line>
                <line x1="36" y1="138" x2="220" y2="52" stroke="#777" stroke-width="2" stroke-dasharray="7 6"></line>
                <line x1="36" y1="138" x2="188" y2="78" stroke="#111" stroke-width="2.8"></line>
                <line x1="188" y1="78" x2="220" y2="52" stroke="#b8b8b8" stroke-width="1.5"></line>
                <line x1="108" y1="24" x2="256" y2="24" stroke="#b2b2b2" stroke-width="1.3"></line>
                <text x="228" y="49" font-size="11" fill="#3b3b3b">drift g_d</text>
                <text x="194" y="76" font-size="11" fill="#111">projected g~</text>
                <text x="110" y="18" font-size="10" fill="#4e4e4e">feasible boundary (anchor-safe)</text>
              </svg>
            </figure>
          </article>

          <article class="mech-card">
            <h3>Operational consequence</h3>
            <ul>
              <li>What moves: adapter update direction in PEFT space.</li>
              <li>What is preserved: first-order anchor alignment budget.</li>
              <li>What stays fixed: optimizer objective and risk controls.</li>
            </ul>
            <p class="mech-note">Result: drift adaptation with explicit memory safety, not implicit hope.</p>
          </article>
        </div>
      </section>

      <section id="atlas" class="section">
        <h2>5. Strategy Atlas (Visual-First)</h2>
        <p class="section-intro">
          Each strategy below is shown as a production-style update pipeline. The visual answers four practical
          questions: what data it uses, what it preserves, what it can change, and where control is enforced.
        </p>

        <article class="strategy-card">
          <header class="strategy-head">
            <p class="method-tag">Established baseline</p>
            <h3>Strategy A: Naive online update</h3>
          </header>
          <div class="strategy-layout">
            <figure class="strategy-diagram" aria-label="Naive strategy pipeline diagram">
              <svg viewBox="0 0 980 228" role="img">
                <rect x="20" y="30" width="165" height="54" fill="#f7f7f7" stroke="#d8d8d8"></rect>
                <text x="33" y="52" font-size="12" fill="#222">Drift stream</text>
                <text x="33" y="70" font-size="11" fill="#555">D_drift(t)</text>

                <rect x="20" y="130" width="165" height="54" fill="#fff" stroke="#b8b8b8" stroke-dasharray="6 5"></rect>
                <text x="33" y="152" font-size="12" fill="#777">Anchor memory</text>
                <text x="33" y="170" font-size="11" fill="#777">unused in update</text>

                <rect x="245" y="70" width="170" height="56" fill="#f7f7f7" stroke="#d8d8d8"></rect>
                <text x="258" y="92" font-size="12" fill="#222">Gradient engine</text>
                <text x="258" y="111" font-size="11" fill="#555">g_d = ∇L_drift</text>

                <rect x="475" y="70" width="160" height="56" fill="#fff" stroke="#d8d8d8"></rect>
                <text x="489" y="92" font-size="12" fill="#222">Control gate</text>
                <text x="489" y="111" font-size="11" fill="#8f2f2f">none</text>

                <rect x="695" y="70" width="160" height="56" fill="#fff" stroke="#555" stroke-width="2"></rect>
                <text x="708" y="92" font-size="12" fill="#222">Adapter update</text>
                <text x="708" y="111" font-size="11" fill="#444">θ ← θ - η g_d</text>

                <line x1="186" y1="58" x2="245" y2="98" stroke="#747474" stroke-width="2"></line>
                <line x1="415" y1="98" x2="475" y2="98" stroke="#747474" stroke-width="2"></line>
                <line x1="635" y1="98" x2="695" y2="98" stroke="#747474" stroke-width="2"></line>

                <rect x="20" y="198" width="935" height="22" fill="#fafafa" stroke="#dcdcdc"></rect>
                <text x="34" y="213" font-size="11" fill="#444">Output path (shared): forecasts (μ̂, Σ̂) → fixed optimizer → weights w*</text>
              </svg>
            </figure>
            <div class="strategy-eval">
              <article><h4>Uses</h4><p>Drift data only.</p></article>
              <article><h4>Preserves</h4><p>No explicit stress memory.</p></article>
              <article><h4>Allows change</h4><p>Maximum short-term adaptation.</p></article>
              <article><h4>Control point</h4><p>No stability gate.</p></article>
            </div>
          </div>
          <div class="strategy-proof">
            <p><strong>Production analog:</strong> unconstrained online model refresh.</p>
            <p><strong>Failure mode addressed:</strong> speed under drift, but weak crisis recall.</p>
            <p><strong>Why this can work:</strong> best when regime persistence is high and stress memory is secondary.</p>
          </div>
        </article>

        <article class="strategy-card">
          <header class="strategy-head">
            <p class="method-tag">Established baseline</p>
            <h3>Strategy B: Anchor-regularized update</h3>
          </header>
          <div class="strategy-layout">
            <figure class="strategy-diagram" aria-label="Anchor regularized strategy pipeline diagram">
              <svg viewBox="0 0 980 228" role="img">
                <rect x="20" y="30" width="165" height="54" fill="#f7f7f7" stroke="#d8d8d8"></rect>
                <text x="33" y="52" font-size="12" fill="#222">Drift stream</text>
                <text x="33" y="70" font-size="11" fill="#555">D_drift(t)</text>

                <rect x="20" y="130" width="165" height="54" fill="#fff" stroke="#0f5fbf" stroke-dasharray="6 5"></rect>
                <text x="33" y="152" font-size="12" fill="#0f5fbf">Anchor memory</text>
                <text x="33" y="170" font-size="11" fill="#0f5fbf">D_anchor(t)</text>

                <rect x="245" y="45" width="170" height="56" fill="#f7f7f7" stroke="#d8d8d8"></rect>
                <text x="258" y="67" font-size="12" fill="#222">Drift gradient</text>
                <text x="258" y="86" font-size="11" fill="#555">g_d</text>

                <rect x="245" y="125" width="170" height="56" fill="#f7f7f7" stroke="#0f5fbf"></rect>
                <text x="258" y="147" font-size="12" fill="#0f5fbf">Anchor gradient</text>
                <text x="258" y="166" font-size="11" fill="#0f5fbf">g_a</text>

                <rect x="475" y="70" width="180" height="56" fill="#fff" stroke="#d8d8d8" stroke-width="2"></rect>
                <text x="489" y="92" font-size="12" fill="#222">Soft control</text>
                <text x="489" y="111" font-size="11" fill="#444">g = g_d + β g_a</text>

                <rect x="715" y="70" width="160" height="56" fill="#fff" stroke="#555" stroke-width="2"></rect>
                <text x="728" y="92" font-size="12" fill="#222">Adapter update</text>
                <text x="728" y="111" font-size="11" fill="#444">θ ← θ - η g</text>

                <line x1="186" y1="58" x2="245" y2="73" stroke="#747474" stroke-width="2"></line>
                <line x1="186" y1="157" x2="245" y2="153" stroke="#0f5fbf" stroke-width="2"></line>
                <line x1="415" y1="73" x2="475" y2="92" stroke="#747474" stroke-width="2"></line>
                <line x1="415" y1="153" x2="475" y2="106" stroke="#0f5fbf" stroke-width="2"></line>
                <line x1="655" y1="98" x2="715" y2="98" stroke="#747474" stroke-width="2"></line>

                <rect x="20" y="198" width="935" height="22" fill="#fafafa" stroke="#dcdcdc"></rect>
                <text x="34" y="213" font-size="11" fill="#444">Output path (shared): forecasts (μ̂, Σ̂) → fixed optimizer → weights w*</text>
              </svg>
            </figure>
            <div class="strategy-eval">
              <article><h4>Uses</h4><p>Drift + anchor memory.</p></article>
              <article><h4>Preserves</h4><p>Stress behavior softly via β.</p></article>
              <article><h4>Allows change</h4><p>Adaptation with penalty.</p></article>
              <article><h4>Control point</h4><p>Objective-level regularization.</p></article>
            </div>
          </div>
          <div class="strategy-proof">
            <p><strong>Production analog:</strong> replay/shrinkage penalties in live signal maintenance.</p>
            <p><strong>Failure mode addressed:</strong> pure forgetting from naive drift-only updates.</p>
            <p><strong>Why this can work:</strong> introduces retention pressure while preserving optimizer invariants.</p>
          </div>
        </article>

        <article class="strategy-card">
          <header class="strategy-head">
            <p class="method-tag proposed">Proposed in this work</p>
            <h3>Strategy C: Anchor + projection update</h3>
          </header>
          <div class="strategy-layout">
            <figure class="strategy-diagram" aria-label="Anchor projection strategy pipeline diagram">
              <svg viewBox="0 0 980 228" role="img">
                <rect x="20" y="30" width="165" height="54" fill="#f7f7f7" stroke="#d8d8d8"></rect>
                <text x="33" y="52" font-size="12" fill="#222">Drift stream</text>
                <text x="33" y="70" font-size="11" fill="#555">D_drift(t)</text>

                <rect x="20" y="130" width="165" height="54" fill="#fff" stroke="#111" stroke-dasharray="6 5"></rect>
                <text x="33" y="152" font-size="12" fill="#111">Anchor memory</text>
                <text x="33" y="170" font-size="11" fill="#111">D_anchor(t)</text>

                <rect x="245" y="45" width="170" height="56" fill="#f7f7f7" stroke="#d8d8d8"></rect>
                <text x="258" y="67" font-size="12" fill="#222">Drift gradient</text>
                <text x="258" y="86" font-size="11" fill="#555">g_d</text>

                <rect x="245" y="125" width="170" height="56" fill="#f7f7f7" stroke="#111"></rect>
                <text x="258" y="147" font-size="12" fill="#111">Anchor gradient</text>
                <text x="258" y="166" font-size="11" fill="#111">g_a</text>

                <rect x="475" y="70" width="200" height="56" fill="#fff" stroke="#111" stroke-width="2"></rect>
                <text x="489" y="92" font-size="12" fill="#111">Hard control gate</text>
                <text x="489" y="111" font-size="11" fill="#111">g~ = Π(g_d | g_a, ε)</text>

                <rect x="735" y="70" width="180" height="56" fill="#fff" stroke="#111" stroke-width="2"></rect>
                <text x="748" y="92" font-size="12" fill="#111">Adapter update</text>
                <text x="748" y="111" font-size="11" fill="#111">θ ← θ - η (g~ + β g_a)</text>

                <line x1="186" y1="58" x2="245" y2="73" stroke="#777" stroke-width="2"></line>
                <line x1="186" y1="157" x2="245" y2="153" stroke="#111" stroke-width="2"></line>
                <line x1="415" y1="73" x2="475" y2="92" stroke="#777" stroke-width="2"></line>
                <line x1="415" y1="153" x2="475" y2="106" stroke="#111" stroke-width="2"></line>
                <line x1="675" y1="98" x2="735" y2="98" stroke="#111" stroke-width="2"></line>

                <rect x="20" y="198" width="935" height="22" fill="#fafafa" stroke="#dcdcdc"></rect>
                <text x="34" y="213" font-size="11" fill="#444">Output path (shared): forecasts (μ̂, Σ̂) → fixed optimizer → weights w*</text>
              </svg>
            </figure>
            <div class="strategy-eval">
              <article><h4>Uses</h4><p>Drift + anchor gradients.</p></article>
              <article><h4>Preserves</h4><p>Anchor alignment up to ε budget.</p></article>
              <article><h4>Allows change</h4><p>Closest feasible adaptation step.</p></article>
              <article><h4>Control point</h4><p>Geometry-level hard constraint.</p></article>
            </div>
          </div>
          <div class="strategy-proof">
            <p><strong>Production analog:</strong> hard risk-limit gates before position changes are accepted.</p>
            <p><strong>Failure mode addressed:</strong> hidden degradation of stress behavior under prolonged drift.</p>
            <p><strong>Why this can work:</strong> adaptation is optimized subject to explicit interference budget.</p>
          </div>
        </article>
      </section>

      <section id="decision" class="section">
        <h2>6. Deployment Decision Surface</h2>
        <p class="section-intro">Read this before looking at run outputs. It states the expected ordering of outcomes.</p>

        <div class="decision-grid">
          <article class="decision-surface" aria-label="Adaptation-retention tradeoff map">
            <h3>Adaptation vs retention map</h3>
            <svg viewBox="0 0 360 230" role="img">
              <line x1="48" y1="184" x2="330" y2="184" stroke="#b5b5b5" stroke-width="1.5"></line>
              <line x1="48" y1="184" x2="48" y2="30" stroke="#b5b5b5" stroke-width="1.5"></line>
              <text x="176" y="214" font-size="11" fill="#444">drift adaptation quality</text>
              <text x="12" y="114" transform="rotate(-90, 12, 114)" font-size="11" fill="#444">stress retention quality</text>

              <circle cx="116" cy="82" r="7" fill="#6e6e6e"></circle>
              <text x="126" y="85" font-size="11" fill="#333">naive</text>

              <circle cx="190" cy="116" r="7" fill="#0f5fbf"></circle>
              <text x="200" y="119" font-size="11" fill="#0f5fbf">anchor</text>

              <circle cx="264" cy="148" r="7" fill="#111"></circle>
              <text x="274" y="151" font-size="11" fill="#111">anchor + projection</text>
            </svg>
          </article>

          <article class="decision-rules">
            <h3>Expected ordering (before experiment)</h3>
            <ul>
              <li>Stress MSE: projection < anchor < naive.</li>
              <li>Drift MSE: naive <= anchor <= projection.</li>
              <li>Drawdown resilience: projection should dominate naive in stress-heavy runs.</li>
              <li>Promotion criterion: ordering must hold across repeated seeds and stress presets.</li>
            </ul>
          </article>
        </div>
      </section>

      <section id="implementation" class="section">
        <h2>7. What To Implement Next</h2>
        <p class="section-intro">A direct build sequence from this page to a production pilot.</p>

        <div class="implementation-grid">
          <article>
            <h3>Step 1: Build anchor memory</h3>
            <ul>
              <li>Define regime tags.</li>
              <li>Assemble pinned stress slices.</li>
              <li>Freeze this set for all method comparisons.</li>
            </ul>
          </article>
          <article>
            <h3>Step 2: Add projection gate</h3>
            <ul>
              <li>Compute \(\mathbf{g}_{\mathrm{d}},\mathbf{g}_{\mathrm{a}}\) each step.</li>
              <li>Project drift gradients into anchor-safe cone.</li>
              <li>Log distortion and interference-rate diagnostics.</li>
            </ul>
          </article>
          <article>
            <h3>Step 3: Decide promotion</h3>
            <ul>
              <li>Run repeated stress-heavy seeds.</li>
              <li>Check ordering in stress MSE, drift MSE, drawdown.</li>
              <li>Promote only if ordering remains stable.</li>
            </ul>
          </article>
        </div>
      </section>

      <section id="validation" class="section" aria-label="Validation">
        <h2>8. Validation Run (Evidence Layer)</h2>
        <p class="section-intro">
          This is a decision tool, not a toy demo. Each mode and figure is designed to test a specific robustness claim.
        </p>

        <article class="protocol-board">
          <h3>Mode design (what each run should prove)</h3>
          <div class="mode-grid">
            <article class="mode-card" data-mode-card="quick_check">
              <h4>Quick</h4>
              <p><strong>Purpose:</strong> fast sanity check of ordering direction.</p>
              <p><strong>Convincing signal:</strong> sign-level separation appears within seconds.</p>
            </article>
            <article class="mode-card" data-mode-card="proposal_like">
              <h4>Default</h4>
              <p><strong>Purpose:</strong> deployment-like balance of drift and stress.</p>
              <p><strong>Convincing signal:</strong> projection wins stress and drawdown with tolerable drift penalty.</p>
            </article>
            <article class="mode-card" data-mode-card="stress_heavy">
              <h4>Stress+</h4>
              <p><strong>Purpose:</strong> adversarial regime concentration.</p>
              <p><strong>Convincing signal:</strong> naive failure becomes obvious, projection remains stable.</p>
            </article>
          </div>
          <p id="mode-readout" class="mode-readout"></p>
        </article>

        <article id="expectation-check" class="expectation-check"></article>

        <div class="control-stack">
          <div class="preset-row">
            <button id="apply-quick" data-preset="quick_check" class="btn btn-ghost" type="button">Quick</button>
            <button id="apply-proposal" data-preset="proposal_like" class="btn btn-ghost" type="button">Default</button>
            <button id="apply-stress" data-preset="stress_heavy" class="btn btn-ghost" type="button">Stress+</button>
          </div>

          <form id="config-form" class="knob-grid">
            <label>Update steps<input name="steps" type="number" step="1" /></label>
            <label>Anchor weight<input name="anchorBeta" type="number" step="0.01" /></label>
            <label>Stress frequency<input name="pStress" type="number" step="0.01" /></label>
            <label>LoRA rank<input name="loraRank" type="number" step="1" /></label>
            <label>Seed<input name="seed" type="number" step="1" /></label>
          </form>

          <div class="action-row">
            <button id="run-demo" class="btn btn-primary" type="button">Run validation</button>
            <button id="reset-form" class="btn btn-ghost" type="button">Reset</button>
            <button id="export-run" class="btn btn-ghost" type="button">Export JSON</button>
          </div>
        </div>

        <div class="run-status">
          <p id="status-line">Ready.</p>
          <div class="progress-track"><div id="progress-fill"></div></div>
        </div>

        <article id="decision-card" class="decision-card"></article>
        <div id="impact-kpis" class="kpi-row"></div>

        <div class="chart-grid">
          <article>
            <h3>Impact vs naive</h3>
            <p class="chart-guide">
              <strong>Read:</strong> bars compare anchor and projection against naive.
              <strong>Convincing signal:</strong> projection dominates stress-retention gain and drawdown improvement.
            </p>
            <canvas id="impact-chart" class="chart-canvas"></canvas>
          </article>
          <article>
            <h3>Equity curves</h3>
            <p class="chart-guide">
              <strong>Read:</strong> compare curve resilience through stress markers.
              <strong>Convincing signal:</strong> projection path avoids deep stress drawdowns while staying competitive.
            </p>
            <canvas id="equity-chart" class="chart-canvas"></canvas>
          </article>
          <article>
            <h3>Regime return split</h3>
            <p class="chart-guide">
              <strong>Read:</strong> drift and stress mean returns by method.
              <strong>Convincing signal:</strong> projection preserves stress return without collapsing drift regime quality.
            </p>
            <canvas id="regime-chart" class="chart-canvas"></canvas>
          </article>
        </div>

        <article class="table-wrap">
          <h3>Method scoreboard</h3>
          <p class="chart-guide">
            <strong>Read:</strong> stress, drawdown, drift, and return in one ranking.
            <strong>Decision use:</strong> promote only if top ranking is consistent across seeds and Stress+ mode.
          </p>
          <table id="method-table" class="method-table"></table>
        </article>

        <article id="takeaway" class="takeaway"></article>
      </section>
    </main>

    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["\\(", "\\)"]],
          displayMath: [["\\[", "\\]"]],
        },
        svg: {
          fontCache: "global",
        },
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script type="module" src="./src/main.js"></script>
  </body>
</html>
