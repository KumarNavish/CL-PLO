<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CL-PLO Spine | Continual Update Design for Portfolio Systems</title>
    <link rel="stylesheet" href="./coreline.css" />
  </head>
  <body>
    <header class="hero" id="top">
      <div class="shell">
        <p class="eyebrow">Continual Learning x Portfolio Optimization</p>
        <h1>When markets drift, how do we update quickly without deleting stress behavior?</h1>
        <p class="lead">
          This page is a deployment decision artifact: it starts from a realistic portfolio research workflow,
          explains the three update strategies with concrete mechanisms, then validates them on the same stream.
        </p>
        <div class="hero-actions">
          <a class="btn btn-primary" href="#problem">Start with the problem</a>
          <a class="btn btn-ghost" href="#strategies">Compare strategies</a>
          <a class="btn btn-ghost" href="#workspace">Run validation</a>
        </div>
      </div>
    </header>

    <main class="shell">
      <section class="section" id="problem">
        <h2>1. Problem First: What Fails in Production</h2>
        <p class="section-intro">
          In live portfolio systems, the optimizer and risk guardrails are mostly fixed. The mutable part is the
          model update rule. During prolonged calm markets, naive updates can overfit drift and forget stress behavior,
          then fail exactly when risk control matters most.
        </p>

        <div class="scenario-strip">
          <article>
            <h3>Step 1: Calm regime</h3>
            <p>Signal model sees repeated drift patterns and adapts aggressively.</p>
          </article>
          <article>
            <h3>Step 2: Stress arrival</h3>
            <p>Liquidity shock appears; old stress logic should still be available.</p>
          </article>
          <article>
            <h3>Step 3: Deployment decision</h3>
            <p>Risk team asks: "Did the updater preserve stress memory, or overwrite it?"</p>
          </article>
        </div>

        <article class="positioning-card">
          <h3>Positioning Relative to Prior Art and Baselines</h3>
          <div class="positioning-grid">
            <article>
              <h4>Research lineage</h4>
              <ul class="citation-list">
                <li>
                  Continual-learning interference control:
                  <a href="https://openreview.net/forum?id=Hkf2_sC5FX" target="_blank" rel="noreferrer">A-GEM (Chaudhry et al., 2019)</a>
                </li>
                <li>
                  PEFT adaptation space:
                  <a href="https://arxiv.org/abs/2106.09685" target="_blank" rel="noreferrer">LoRA (Hu et al., 2022)</a>
                </li>
                <li>
                  Projection in continual PEFT:
                  <a href="https://arxiv.org/abs/2405.13383" target="_blank" rel="noreferrer">Qiao et al. (2024)</a>
                </li>
                <li>
                  Constrained portfolio optimization:
                  <a href="https://web.stanford.edu/~boyd/papers/pdf/cvx_portfolio.pdf" target="_blank" rel="noreferrer">Boyd et al. (2017)</a>
                </li>
              </ul>
            </article>
            <article>
              <h4>Production baselines</h4>
              <ul class="citation-list">
                <li>
                  Constraint-aware allocator baseline:
                  <a href="https://github.com/cvxgrp/cvxportfolio" target="_blank" rel="noreferrer">cvxportfolio</a>
                </li>
                <li>
                  Research stack baseline:
                  <a href="https://github.com/microsoft/qlib" target="_blank" rel="noreferrer">Microsoft Qlib</a>
                </li>
                <li>
                  Backtest and portfolio engine baseline:
                  <a href="https://github.com/quantopian/zipline" target="_blank" rel="noreferrer">Zipline</a>
                </li>
                <li>
                  CL benchmarking baseline:
                  <a href="https://github.com/ContinualAI/avalanche" target="_blank" rel="noreferrer">Avalanche</a>
                </li>
              </ul>
            </article>
          </div>
        </article>
      </section>

      <section class="section" id="concepts">
        <h2>2. Concrete Meaning of the Core Objects</h2>
        <p class="section-intro">
          Before introducing symbols, define what each object means operationally in a quant workflow.
        </p>

        <div class="concept-grid">
          <article class="concept-card">
            <h3>Anchor set: a fixed stress fixture, not an abstract buffer</h3>
            <p>
              An anchor set is a persistent mini-dataset used at every update step to protect stress behavior.
              In practice it is built from scenario slices the desk already cares about.
            </p>

            <table class="anchor-table">
              <thead>
                <tr>
                  <th>Anchor slice</th>
                  <th>Example inputs</th>
                  <th>What should be preserved</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Liquidity shock</td>
                  <td>spread blowout, funding stress, gap-down tape</td>
                  <td>rapid de-risking response</td>
                </tr>
                <tr>
                  <td>Inflation shock</td>
                  <td>macro surprise, rates up, growth down</td>
                  <td>factor rotation behavior</td>
                </tr>
                <tr>
                  <td>Idiosyncratic stress</td>
                  <td>single-sector crash or earnings collapse</td>
                  <td>exposure clipping and turnover discipline</td>
                </tr>
              </tbody>
            </table>

            <p class="concept-note">
              In this demo, anchors are synthetic stress regimes, but the operational role is the same as curated
              historical crisis slices in production.
            </p>
          </article>

          <article class="concept-card">
            <h3>Projection: turn a risky update into the closest safe update</h3>
            <p>
              What is projected: the drift gradient update. Against what: the anchor gradient direction.
              Why: to block updates that would increase anchor loss too much.
            </p>

            <figure class="projection-figure" aria-label="Gradient projection mechanism">
              <svg viewBox="0 0 520 260" role="img">
                <defs>
                  <marker id="arrow-anchor" viewBox="0 0 10 10" refX="7.5" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#0f5fbf" />
                  </marker>
                  <marker id="arrow-drift" viewBox="0 0 10 10" refX="7.5" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#8f2f2f" />
                  </marker>
                  <marker id="arrow-safe" viewBox="0 0 10 10" refX="7.5" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#b55400" />
                  </marker>
                </defs>

                <line class="proj-axis" x1="70" y1="220" x2="470" y2="220" />
                <line class="proj-axis" x1="70" y1="220" x2="70" y2="30" />

                <line class="proj-boundary" x1="110" y1="205" x2="410" y2="85" />
                <text class="proj-text" x="312" y="78">safe half-space boundary</text>

                <line class="proj-vector-anchor" x1="70" y1="220" x2="210" y2="110" marker-end="url(#arrow-anchor)" />
                <text class="proj-text" x="214" y="103">anchor gradient \(g_a\)</text>

                <line class="proj-vector-drift" x1="70" y1="220" x2="392" y2="206" marker-end="url(#arrow-drift)" />
                <text class="proj-text" x="396" y="203">raw drift step \(g_d\)</text>

                <line class="proj-drop" x1="392" y1="206" x2="330" y2="145" />
                <circle class="proj-point" cx="330" cy="145" r="4" />

                <line class="proj-vector-safe" x1="70" y1="220" x2="330" y2="145" marker-end="url(#arrow-safe)" />
                <text class="proj-text" x="335" y="138">projected safe step \(\tilde g\)</text>
              </svg>
            </figure>

            <ul class="projection-list">
              <li><strong>Unsafe step:</strong> raw drift update crosses the safety boundary.</li>
              <li><strong>Projection:</strong> find the nearest step that satisfies anchor interference control.</li>
              <li><strong>Result:</strong> preserve adaptation signal while enforcing stability budget.</li>
            </ul>
          </article>
        </div>

        <article class="object-map">
          <h3>Objects Before Symbols</h3>
          <table class="map-table">
            <thead>
              <tr>
                <th>Operational object</th>
                <th>Symbol</th>
                <th>Used where</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Current regime training stream</td>
                <td>\(\mathcal{D}^{\mathrm{drift}}_t\)</td>
                <td>all strategies</td>
              </tr>
              <tr>
                <td>Stress fixture / replay anchors</td>
                <td>\(\mathcal{D}^{\mathrm{anchor}}_t\)</td>
                <td>anchor and constrained strategies</td>
              </tr>
              <tr>
                <td>Drift gradient</td>
                <td>\(g_{d,t}\)</td>
                <td>all strategies</td>
              </tr>
              <tr>
                <td>Anchor gradient</td>
                <td>\(g_{a,t}\)</td>
                <td>anchor and constrained strategies</td>
              </tr>
              <tr>
                <td>Projected safe gradient</td>
                <td>\(\tilde g_t\)</td>
                <td>constrained strategy</td>
              </tr>
              <tr>
                <td>Portfolio decision</td>
                <td>\(w_t^\star\)</td>
                <td>fixed optimizer layer</td>
              </tr>
            </tbody>
          </table>
        </article>
      </section>

      <section class="section" id="strategies">
        <h2>3. Three Strategy Systems (Operational Comparison)</h2>
        <p class="section-intro">
          Same backbone, same optimizer, same stream. Only the update law changes.
        </p>

        <article class="strategy-card">
          <header class="strategy-head">
            <p class="method-tag">Established baseline</p>
            <h3>Strategy A: Naive online update</h3>
            <p class="strategy-claim">Optimize immediate fit to new data; no explicit memory protection.</p>
          </header>

          <div class="pipeline-diagram">
            <div class="pipe-node source"><h4>Input</h4><p>Drift batch \(\mathcal{D}^{\mathrm{drift}}_t\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node off"><h4>Anchor set</h4><p>Not used</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node off"><h4>Control</h4><p>No interference gate</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node update"><h4>Update</h4><p>\(\theta_{t+1}=\theta_t-\eta_t g_{d,t}\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node output"><h4>Output</h4><p>\((\mu_t,\Sigma_t)\mapsto w_t^\star\)</p></div>
          </div>

          <div class="strategy-ledger">
            <article><h4>Uses</h4><p>Current drift information only.</p></article>
            <article><h4>Preserves</h4><p>Maximum adaptation speed.</p></article>
            <article><h4>Allows to change</h4><p>Any direction in parameter space.</p></article>
            <article><h4>Failure mode addressed</h4><p>None; vulnerable to forgetting.</p></article>
          </div>

          <p class="strategy-rationale">
            Why it can work: in stable, low-regime-volatility periods it captures drift quickly. Why it fails: no
            mechanism prevents stress-memory erosion.
          </p>
          <p class="strategy-cite">
            Grounding:
            <a href="https://dl.acm.org/doi/10.1145/2638548" target="_blank" rel="noreferrer">online portfolio selection baselines</a>.
          </p>
        </article>

        <article class="strategy-card">
          <header class="strategy-head">
            <p class="method-tag">Established baseline</p>
            <h3>Strategy B: Replay-regularized update</h3>
            <p class="strategy-claim">Add anchor replay so stress behavior receives continuous corrective pressure.</p>
          </header>

          <div class="pipeline-diagram">
            <div class="pipe-node source"><h4>Input</h4><p>Drift batch \(\mathcal{D}^{\mathrm{drift}}_t\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node memory"><h4>Anchor set</h4><p>Stress fixture \(\mathcal{D}^{\mathrm{anchor}}_t\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node soft"><h4>Control</h4><p>Soft penalty weight \(\beta_t\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node update"><h4>Update</h4><p>\(\theta_{t+1}=\theta_t-\eta_t(g_{d,t}+\beta_t g_{a,t})\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node output"><h4>Output</h4><p>\((\mu_t,\Sigma_t)\mapsto w_t^\star\)</p></div>
          </div>

          <div class="strategy-ledger">
            <article><h4>Uses</h4><p>Drift stream + stress anchors.</p></article>
            <article><h4>Preserves</h4><p>Stress behavior in expectation.</p></article>
            <article><h4>Allows to change</h4><p>All directions, but weighted by replay pressure.</p></article>
            <article><h4>Failure mode addressed</h4><p>Partial forgetting; may still drift away under long pressure.</p></article>
          </div>

          <p class="strategy-rationale">
            Why it can work: a stable compromise between adaptation and memory. Trade-off: soft penalties do not enforce
            a hard safety boundary.
          </p>
          <p class="strategy-cite">
            Grounding:
            <a href="https://arxiv.org/abs/2106.09685" target="_blank" rel="noreferrer">LoRA PEFT setup</a>,
            <a href="https://github.com/ContinualAI/avalanche" target="_blank" rel="noreferrer">replay baselines in Avalanche</a>.
          </p>
        </article>

        <article class="strategy-card">
          <header class="strategy-head">
            <p class="method-tag proposed">Proposed in this work</p>
            <h3>Strategy C: Replay + projected constrained update</h3>
            <p class="strategy-claim">Reject harmful gradient components before update; replay then refines inside safe region.</p>
          </header>

          <div class="pipeline-diagram">
            <div class="pipe-node source"><h4>Input</h4><p>Drift batch \(\mathcal{D}^{\mathrm{drift}}_t\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node memory"><h4>Anchor set</h4><p>Stress fixture \(\mathcal{D}^{\mathrm{anchor}}_t\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node hard"><h4>Control</h4><p>\(\tilde g_t=\Pi(g_{d,t}\mid g_{a,t},\varepsilon_t)\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node update"><h4>Update</h4><p>\(\theta_{t+1}=\theta_t-\eta_t(\tilde g_t+\beta_t g_{a,t})\)</p></div>
            <div class="pipe-arrow">→</div>
            <div class="pipe-node output"><h4>Output</h4><p>\((\mu_t,\Sigma_t)\mapsto w_t^\star\)</p></div>
          </div>

          <div class="strategy-ledger">
            <article><h4>Uses</h4><p>Drift stream + stress anchors + interference budget.</p></article>
            <article><h4>Preserves</h4><p>Anchor alignment with explicit geometric constraint.</p></article>
            <article><h4>Allows to change</h4><p>Only updates inside safe half-space.</p></article>
            <article><h4>Failure mode addressed</h4><p>Stress-memory collapse under persistent drift.</p></article>
          </div>

          <p class="strategy-rationale">
            Why it is principled: this is the direct analogue of hard risk limits in portfolio construction. It resolves
            the speed-vs-stability trade-off by constraining only the harmful update component, not all adaptation.
          </p>
          <p class="strategy-cite">
            Grounding:
            <a href="https://openreview.net/forum?id=Hkf2_sC5FX" target="_blank" rel="noreferrer">A-GEM projection</a>,
            <a href="https://arxiv.org/abs/2405.13383" target="_blank" rel="noreferrer">projection in continual PEFT</a>.
          </p>
        </article>
      </section>

      <section class="section" id="math">
        <h2>4. Formal Layer (After Intuition)</h2>
        <p class="section-intro">
          The first two equations are established components. The third is the proposal-specific update law.
        </p>

        <div class="math-grid">
          <article class="math-card">
            <p class="math-tag literature">Established</p>
            <h3>Portfolio decision layer</h3>
            <p class="math-block">
              \[
              w_t^\star=
              \arg\max_{w\in\mathcal{W}}
              \left(
              \mu_t^\top w-
              \frac{\gamma}{2}w^\top\Sigma_t w-
              \lambda_{\mathrm{tc}}\|w-w_{t-1}\|_1
              \right)
              \]
            </p>
          </article>

          <article class="math-card">
            <p class="math-tag literature">Established</p>
            <h3>Replay-regularized continual update</h3>
            <p class="math-block">
              \[
              \theta_{t+1}=\theta_t-\eta_t\nabla
              \left(
              \mathcal{L}_{\mathrm{drift},t}(\theta_t)+
              \beta_t\mathcal{L}_{\mathrm{anchor},t}(\theta_t)
              \right)
              \]
            </p>
          </article>

          <article class="math-card">
            <p class="math-tag proposal">Proposed here</p>
            <h3>Projected safe update</h3>
            <p class="math-block">
              \[
              \tilde g_t=
              \arg\min_{v}\|v-g_{d,t}\|_2^2
              \;\text{s.t.}\;
              \langle v,g_{a,t}\rangle\ge-\varepsilon_t,
              \qquad
              \theta_{t+1}=\theta_t-\eta_t(\tilde g_t+\beta_t g_{a,t})
              \]
            </p>
          </article>
        </div>
      </section>

      <section class="section" id="workspace" aria-label="Validation Workspace">
        <h2>5. Evidence Workspace (Interactive)</h2>
        <p class="section-intro">
          Run the same stream under all three strategies. Use mode settings to test directional behavior, realistic
          operation, and adversarial stress concentration.
        </p>

        <article class="protocol-board">
          <h3>Validation modes</h3>
          <div class="mode-grid">
            <article class="mode-card" data-mode-card="quick_check">
              <h4>Quick</h4>
              <p>Fast directional check: verify ordering before deep runs.</p>
            </article>
            <article class="mode-card" data-mode-card="proposal_like">
              <h4>Default</h4>
              <p>Deployment-like mix of drift and stress.</p>
            </article>
            <article class="mode-card" data-mode-card="stress_heavy">
              <h4>Stress+</h4>
              <p>Adversarial concentration to expose failure modes.</p>
            </article>
          </div>
          <p id="mode-readout" class="mode-readout"></p>
        </article>

        <div class="control-stack">
          <div class="preset-row">
            <button id="apply-quick" data-preset="quick_check" class="btn btn-ghost" type="button">Quick</button>
            <button id="apply-proposal" data-preset="proposal_like" class="btn btn-ghost" type="button">Default</button>
            <button id="apply-stress" data-preset="stress_heavy" class="btn btn-ghost" type="button">Stress+</button>
          </div>

          <form id="config-form" class="knob-grid">
            <label>
              Update steps
              <input name="steps" type="number" step="1" />
            </label>
            <label>
              Anchor weight
              <input name="anchorBeta" type="number" step="0.01" />
            </label>
            <label>
              Stress frequency
              <input name="pStress" type="number" step="0.01" />
            </label>
            <label>
              LoRA rank
              <input name="loraRank" type="number" step="1" />
            </label>
            <label>
              Seed
              <input name="seed" type="number" step="1" />
            </label>
          </form>

          <div class="action-row">
            <button id="run-demo" class="btn btn-primary" type="button">Run Demo</button>
            <button id="reset-form" class="btn btn-ghost" type="button">Reset</button>
            <button id="export-run" class="btn btn-ghost" type="button">Export JSON</button>
          </div>
        </div>

        <div class="run-status">
          <p id="status-line">Ready.</p>
          <div class="progress-track"><div id="progress-fill"></div></div>
        </div>

        <div class="decision-panels">
          <article id="expectation-check" class="expectation-check"></article>
          <article id="decision-card" class="decision-card"></article>
        </div>

        <div id="impact-kpis" class="kpi-row"></div>

        <div class="chart-grid">
          <article class="chart-card">
            <h3>Impact vs naive</h3>
            <p class="chart-question">Question: does extra control buy stress protection worth the drift-fit cost?</p>
            <canvas id="impact-chart" class="chart-canvas"></canvas>
            <p class="chart-reading" id="impact-reading"></p>
          </article>
          <article class="chart-card">
            <h3>Equity through regimes</h3>
            <p class="chart-question">Question: who absorbs stress pockets without breaking in drift windows?</p>
            <canvas id="equity-chart" class="chart-canvas"></canvas>
            <p class="chart-reading" id="equity-reading"></p>
          </article>
          <article class="chart-card">
            <h3>Regime return split</h3>
            <p class="chart-question">Question: where each method earns vs loses.</p>
            <canvas id="regime-chart" class="chart-canvas"></canvas>
            <p class="chart-reading" id="regime-reading"></p>
          </article>
        </div>

        <article class="table-wrap">
          <h3>Method scoreboard</h3>
          <p class="table-guide">Rank methods, then re-run Stress+ across seeds before promotion.</p>
          <table id="method-table" class="method-table"></table>
        </article>

        <article id="takeaway" class="takeaway"></article>
      </section>

      <section class="section" id="references">
        <h2>6. References</h2>
        <div class="refs-grid">
          <article>
            <h3>Papers</h3>
            <ul id="ref-papers" class="ref-list"></ul>
          </article>
          <article>
            <h3>Datasets</h3>
            <ul id="ref-datasets" class="ref-list"></ul>
          </article>
          <article>
            <h3>Repositories</h3>
            <ul id="ref-repos" class="ref-list"></ul>
          </article>
        </div>
      </section>
    </main>

    <footer class="footer">
      <div class="shell footer-inner">
        <a href="#top" class="inline-link">Back to top</a>
        <p>Problem -> mechanism -> theory -> evidence -> deployment decision.</p>
      </div>
    </footer>

    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["\\(", "\\)"]],
          displayMath: [["\\[", "\\]"]],
        },
        svg: {
          fontCache: "global",
        },
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script type="module" src="./src/main.js"></script>
  </body>
</html>
