<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CL-PLO Spine | Continual Transformer Updates for Portfolio Systems</title>
    <link rel="stylesheet" href="./coreline.css" />
  </head>
  <body>
    <header class="hero" id="top">
      <div class="shell">
        <p class="eyebrow">Continual Learning x LLM Portfolio Systems</p>
        <h1>Update a Transformer fast enough for drift, without forgetting stress behavior.</h1>
        <p class="lead">
          This page is one decision flow for deployed quant systems: define the failure mode, map concrete objects,
          formalize the update law, compare three strategies, and validate on the same stream.
        </p>
        <div class="hero-actions">
          <a class="btn btn-primary" href="#problem">Start</a>
          <a class="btn btn-ghost" href="#strategies">Pipelines</a>
          <a class="btn btn-ghost" href="#workspace">Run Validation</a>
        </div>
      </div>
    </header>

    <main class="shell">
      <section class="section" id="problem">
        <h2>1. Problem Intuition</h2>
        <p class="section-intro">
          In production, the risk optimizer is stable. The mutable component is the LLM adapter update rule.
          During long calm periods, naive updates can overwrite stress behavior; when regime breaks arrive,
          the model reacts with the wrong risk posture. Every experiment below uses a Transformer backbone with LoRA
          adapters; no non-LLM control path is mixed into the testbed.
        </p>

        <div class="problem-strip">
          <article>
            <h3>Deployed stack</h3>
            <p>Frozen Transformer backbone + small LoRA adapter + fixed risk optimizer.</p>
          </article>
          <article>
            <h3>Observed failure</h3>
            <p>Adapter tracks drift and forgets stress patterns required for drawdown control.</p>
          </article>
          <article>
            <h3>Decision question</h3>
            <p>Which update policy preserves stress memory while still adapting to drift?</p>
          </article>
        </div>

        <figure class="timeline-figure" aria-label="Deployment failure timeline">
          <div class="timeline-stage">
            <h4>Calm regime</h4>
            <p>Repeated drift samples dominate updates.</p>
          </div>
          <div class="timeline-arrow">→</div>
          <div class="timeline-stage">
            <h4>Stress transition</h4>
            <p>Liquidity and macro shock enter stream.</p>
          </div>
          <div class="timeline-arrow">→</div>
          <div class="timeline-stage">
            <h4>Portfolio impact</h4>
            <p>Model state quality now directly controls risk response.</p>
          </div>
        </figure>
      </section>

      <section class="section" id="positioning">
        <h2>2. Positioning to Prior Work and Practice</h2>
        <p class="section-intro">
          This project stays inside known building blocks: continual-learning retention controls, Transformer PEFT,
          and constrained portfolio construction. The contribution is how they are wired as one operational contract.
        </p>

        <div class="positioning-grid">
          <article>
            <h3>Research Literature Used Here</h3>
            <ul id="ref-papers" class="ref-list"></ul>
          </article>
          <article>
            <h3>Production Baseline Repositories</h3>
            <ul id="ref-repos" class="ref-list"></ul>
          </article>
          <article>
            <h3>Data Sources for Stress Fixtures</h3>
            <ul id="ref-datasets" class="ref-list"></ul>
          </article>
        </div>
      </section>

      <section class="section" id="objects">
        <h2>3. Concrete Meaning of Core Objects</h2>
        <p class="section-intro">
          Anchor sets, memory, and projection are shown as real system artifacts before formal symbols are introduced.
        </p>

        <div class="objects-grid">
          <article class="object-card">
            <h3>Anchor Set = Persistent Stress Fixture</h3>
            <p class="object-caption">
              The anchor is a fixed replay slice used at every update step. In live research stacks, this is curated from
              stress episodes and risk-review scenarios.
            </p>
            <table class="anchor-table">
              <thead>
                <tr>
                  <th>Anchor bucket</th>
                  <th>Concrete slice</th>
                  <th>Protected behavior</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Liquidity stress</td>
                  <td>widening spreads, gap-open days, funding squeeze</td>
                  <td>de-risk quickly, cap risky weights</td>
                </tr>
                <tr>
                  <td>Macro shock</td>
                  <td>inflation surprises, policy shock windows</td>
                  <td>preserve defensive factor response</td>
                </tr>
                <tr>
                  <td>Concentrated drawdown</td>
                  <td>single-sector crash episodes</td>
                  <td>avoid unstable concentration</td>
                </tr>
              </tbody>
            </table>
          </article>

          <article class="object-card">
            <h3>Mean Projection = Closest Safe Update</h3>
            <p class="object-caption">
              Operationally: take the raw drift update, test interference with anchor direction, and replace it with the
              nearest update that respects stability budget.
            </p>

            <div class="projection-diagram" aria-label="Projection mechanism as operational workflow">
              <div class="proj-node">
                <h4>Raw drift step</h4>
                <p>adapter gradient from current stream</p>
                <p class="math-inline">\(g_{d,t}\)</p>
              </div>
              <div class="proj-arrow">→</div>
              <div class="proj-node constraint">
                <h4>Interference check</h4>
                <p>compare against anchor direction</p>
                <p class="math-inline">\(\langle g_{d,t},g_{a,t}\rangle\)</p>
              </div>
              <div class="proj-arrow">→</div>
              <div class="proj-node safe">
                <h4>Projected safe step</h4>
                <p>closest feasible update</p>
                <p class="math-inline">\(\tilde g_t=\Pi(g_{d,t}\mid g_{a,t},\varepsilon_t)\)</p>
              </div>
            </div>

            <ul class="object-points">
              <li>What is projected: the drift gradient step.</li>
              <li>Against what: anchor-gradient safety boundary.</li>
              <li>Why: block harmful interference while retaining adaptation signal.</li>
            </ul>
          </article>

          <article class="object-card span-2">
            <h3>Object-to-Symbol Map (Defined Once)</h3>
            <table class="map-table">
              <thead>
                <tr>
                  <th>System artifact</th>
                  <th>Symbol</th>
                  <th>Role in pipeline</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Current market stream for adapter updates</td>
                  <td>\(\mathcal{D}^{\mathrm{drift}}_t\)</td>
                  <td>adaptation signal</td>
                </tr>
                <tr>
                  <td>Stress replay fixture</td>
                  <td>\(\mathcal{D}^{\mathrm{anchor}}_t\)</td>
                  <td>memory protection</td>
                </tr>
                <tr>
                  <td>Drift update direction</td>
                  <td>\(g_{d,t}\)</td>
                  <td>what tries to change model state</td>
                </tr>
                <tr>
                  <td>Anchor update direction</td>
                  <td>\(g_{a,t}\)</td>
                  <td>what encodes protected behavior</td>
                </tr>
                <tr>
                  <td>Projected update</td>
                  <td>\(\tilde g_t\)</td>
                  <td>safe adaptation step</td>
                </tr>
                <tr>
                  <td>Executed portfolio decision</td>
                  <td>\(w_t^\star\)</td>
                  <td>fixed decision layer output</td>
                </tr>
              </tbody>
            </table>
          </article>
        </div>
      </section>

      <section class="section" id="math">
        <h2>4. Mathematical Formulation</h2>
        <p class="section-intro">
          Equations appear only after object grounding. Blocks are explicitly labeled by status: prior work vs proposed here.
        </p>

        <div class="math-grid">
          <article class="math-card">
            <p class="math-tag literature">Established in prior work</p>
            <h3>Constrained portfolio decision layer</h3>
            <p class="math-block">
              \[
              w_t^\star=
              \arg\max_{w\in\mathcal{W}}
              \left(
              \mu_t^\top w-
              \frac{\gamma}{2}w^\top\Sigma_t w-
              \lambda_{\mathrm{tc}}\|w-w_{t-1}\|_1
              \right)
              \]
            </p>
            <p class="math-note">Operationally: convert forecasts into feasible weights under fixed risk and turnover controls.</p>
          </article>

          <article class="math-card">
            <p class="math-tag literature">Established in prior work</p>
            <h3>Replay-regularized adapter update</h3>
            <p class="math-block">
              \[
              \theta_{t+1}=\theta_t-
              \eta_t\nabla\!
              \left(
              \mathcal{L}_{\mathrm{drift},t}(\theta_t)+
              \beta_t\mathcal{L}_{\mathrm{anchor},t}(\theta_t)
              \right)
              \]
            </p>
            <p class="math-note">Operationally: keep pulling updates toward anchor behavior through soft replay pressure.</p>
          </article>

          <article class="math-card">
            <p class="math-tag proposal">Proposed here</p>
            <h3>Projected constrained update for LLM adapter</h3>
            <p class="math-block">
              \[
              \tilde g_t=
              \arg\min_{v}\|v-g_{d,t}\|_2^2
              \;\text{s.t.}\;
              \langle v,g_{a,t}\rangle\ge-\varepsilon_t,
              \qquad
              \theta_{t+1}=\theta_t-\eta_t(\tilde g_t+\beta_t g_{a,t})
              \]
            </p>
            <p class="math-note">Operationally: allow adaptation, but remove the update component that damages stress memory.</p>
          </article>
        </div>
      </section>

      <section class="section" id="strategies">
        <h2>5. Strategy Pipelines</h2>
        <p class="section-intro">
          Three competing decision systems are shown with one visual grammar. Same Transformer backbone, different update control.
        </p>

        <div class="strategy-grid">
          <article class="strategy-card">
            <header>
              <p class="method-tag">Baseline</p>
              <h3>A. Naive online update</h3>
            </header>
            <div class="pipeline-stack">
              <div class="stack-node"><h4>Input</h4><p>\(\mathcal{D}^{\mathrm{drift}}_t\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node frozen"><h4>Frozen</h4><p>Transformer backbone \(\phi\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node"><h4>Anchor memory</h4><p>not used</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node danger"><h4>Update</h4><p>\(\theta_{t+1}=\theta_t-\eta_t g_{d,t}\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node"><h4>Decision layer</h4><p>\((\mu_t,\Sigma_t)\to w_t^\star\)</p></div>
            </div>
            <p class="pipeline-note">Preserves speed; no explicit stability control.</p>
          </article>

          <article class="strategy-card">
            <header>
              <p class="method-tag">Baseline</p>
              <h3>B. Replay-regularized</h3>
            </header>
            <div class="pipeline-stack">
              <div class="stack-node"><h4>Input</h4><p>\(\mathcal{D}^{\mathrm{drift}}_t\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node frozen"><h4>Frozen</h4><p>Transformer backbone \(\phi\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node memory"><h4>Anchor memory</h4><p>\(\mathcal{D}^{\mathrm{anchor}}_t\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node"><h4>Update</h4><p>\(\theta_{t+1}=\theta_t-\eta_t(g_{d,t}+\beta_t g_{a,t})\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node"><h4>Decision layer</h4><p>\((\mu_t,\Sigma_t)\to w_t^\star\)</p></div>
            </div>
            <p class="pipeline-note">Adds soft memory pressure; no hard interference boundary.</p>
          </article>

          <article class="strategy-card">
            <header>
              <p class="method-tag proposed">Proposed here</p>
              <h3>C. Replay + projection</h3>
            </header>
            <div class="pipeline-stack">
              <div class="stack-node"><h4>Input</h4><p>\(\mathcal{D}^{\mathrm{drift}}_t\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node frozen"><h4>Frozen</h4><p>Transformer backbone \(\phi\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node memory"><h4>Anchor memory</h4><p>\(\mathcal{D}^{\mathrm{anchor}}_t\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node safe"><h4>Projected update</h4><p>\(\theta_{t+1}=\theta_t-\eta_t(\tilde g_t+\beta_t g_{a,t})\)</p></div>
              <div class="stack-arrow">↓</div>
              <div class="stack-node"><h4>Decision layer</h4><p>\((\mu_t,\Sigma_t)\to w_t^\star\)</p></div>
            </div>
            <p class="pipeline-note">Hard stability gate before state update; closest analogue to production risk limits.</p>
          </article>
        </div>
      </section>

      <section class="section" id="workspace" aria-label="Validation Workspace">
        <h2>6. Experiments (Interactive)</h2>
        <p class="section-intro">
          Plots are decision tools, not decoration. Each chart asks a deployment-relevant question and the readout states
          what would count as supporting evidence.
        </p>

        <article class="protocol-board">
          <h3>Validation modes</h3>
          <div class="mode-grid">
            <article class="mode-card" data-mode-card="quick_check">
              <h4>Quick</h4>
              <p>Fast directional test.</p>
            </article>
            <article class="mode-card" data-mode-card="proposal_like">
              <h4>Default</h4>
              <p>Deployment-like drift/stress mix.</p>
            </article>
            <article class="mode-card" data-mode-card="stress_heavy">
              <h4>Stress+</h4>
              <p>Adversarial stress concentration.</p>
            </article>
          </div>
          <p id="mode-readout" class="mode-readout"></p>
        </article>

        <div class="control-stack">
          <div class="preset-row">
            <button id="apply-quick" data-preset="quick_check" class="btn btn-ghost" type="button">Quick</button>
            <button id="apply-proposal" data-preset="proposal_like" class="btn btn-ghost" type="button">Default</button>
            <button id="apply-stress" data-preset="stress_heavy" class="btn btn-ghost" type="button">Stress+</button>
          </div>

          <form id="config-form" class="knob-grid">
            <label>
              Update steps
              <input name="steps" type="number" step="1" />
            </label>
            <label>
              Anchor weight
              <input name="anchorBeta" type="number" step="0.01" />
            </label>
            <label>
              Stress frequency
              <input name="pStress" type="number" step="0.01" />
            </label>
            <label>
              LoRA rank
              <input name="loraRank" type="number" step="1" />
            </label>
            <label>
              Seed
              <input name="seed" type="number" step="1" />
            </label>
          </form>

          <div class="action-row">
            <button id="run-demo" class="btn btn-primary" type="button">Run Demo</button>
            <button id="reset-form" class="btn btn-ghost" type="button">Reset</button>
            <button id="export-run" class="btn btn-ghost" type="button">Export JSON</button>
          </div>
        </div>

        <div class="run-status">
          <p id="status-line">Ready.</p>
          <div class="progress-track"><div id="progress-fill"></div></div>
        </div>

        <div class="decision-panels">
          <article id="expectation-check" class="expectation-check"></article>
          <article id="decision-card" class="decision-card"></article>
        </div>

        <div id="impact-kpis" class="kpi-row"></div>

        <div class="chart-grid">
          <article class="chart-card">
            <h3>Impact vs naive</h3>
            <p class="chart-question">Question: does added control buy enough stress protection?</p>
            <canvas id="impact-chart" class="chart-canvas"></canvas>
            <p class="chart-reading" id="impact-reading"></p>
          </article>
          <article class="chart-card">
            <h3>Equity through regimes</h3>
            <p class="chart-question">Question: who survives stress pockets without drift collapse?</p>
            <canvas id="equity-chart" class="chart-canvas"></canvas>
            <p class="chart-reading" id="equity-reading"></p>
          </article>
          <article class="chart-card">
            <h3>Regime return split</h3>
            <p class="chart-question">Question: where each strategy wins or fails.</p>
            <canvas id="regime-chart" class="chart-canvas"></canvas>
            <p class="chart-reading" id="regime-reading"></p>
          </article>
        </div>

        <article class="table-wrap">
          <h3>Method scoreboard</h3>
          <p class="table-guide">Rank methods, then re-run Stress+ across seeds before promotion.</p>
          <table id="method-table" class="method-table"></table>
        </article>
      </section>

      <section class="section" id="synthesis">
        <h2>7. End-to-End Takeaway</h2>
        <p class="section-intro">
          Final synthesis: one deployment pathway from stream update to portfolio decision gate.
        </p>

        <figure class="synthesis-diagram" aria-label="End-to-end deployment pathway">
          <div class="syn-node">
            <h4>LLM stream input</h4>
            <p>market state + text context</p>
          </div>
          <div class="syn-arrow">→</div>
          <div class="syn-node">
            <h4>Anchor fixture</h4>
            <p>stress memory slices</p>
          </div>
          <div class="syn-arrow">→</div>
          <div class="syn-node highlight">
            <h4>Constrained adapter update</h4>
            <p>\(\tilde g_t=\Pi(g_{d,t}\mid g_{a,t},\varepsilon_t)\)</p>
          </div>
          <div class="syn-arrow">→</div>
          <div class="syn-node">
            <h4>Fixed optimizer</h4>
            <p>\((\mu_t,\Sigma_t)\to w_t^\star\)</p>
          </div>
          <div class="syn-arrow">→</div>
          <div class="syn-node">
            <h4>Release gate</h4>
            <p>promote or reject update policy</p>
          </div>
        </figure>

        <article id="takeaway" class="takeaway"></article>

        <article class="close-card">
          <h3>Concise conclusions</h3>
          <ul>
            <li>The CL to portfolio link is operational: update constraints behave like risk limits on model state changes.</li>
            <li>Anchor fixtures are concrete artifacts: curated stress slices that remain in every update cycle.</li>
            <li>Projection is the mechanism that preserves stability without freezing adaptation.</li>
          </ul>
        </article>
      </section>
    </main>

    <footer class="footer">
      <div class="shell footer-inner">
        <a href="#top" class="inline-link">Back to top</a>
        <p>Intuition -> positioning -> objects -> math -> pipelines -> evidence -> decision.</p>
      </div>
    </footer>

    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["\\(", "\\)"]],
          displayMath: [["\\[", "\\]"]],
        },
        svg: {
          fontCache: "global",
        },
      };
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script type="module" src="./src/main.js"></script>
  </body>
</html>
